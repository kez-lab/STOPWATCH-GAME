---
description: 
globs: 
alwaysApply: true
---
// Compose Multiplatform .cursorrules

// Flexibility Notice
// Note: This structure is recommended but should be adapted to existing project architecture.
// Compose Multiplatform aims to share as much logic and UI as possible, while allowing platform-specific customization when needed.

const kmpComposeBestPractices = [
  // üîß Íµ¨Ï°∞ Î∞è ÏïÑÌÇ§ÌÖçÏ≤ò
  "Organize shared logic in the shared module (domain, data, utils, etc.)",
  "Use Compose Multiplatform for UI with platform-specific code handled via expect/actual or platform sourceSets",
  "Separate platform-specific features in androidMain, iosMain, webMain",
  "Manage business logic in ViewModels and UseCases",
  "Use Compose State + Coroutine Flow for state management",
  "Use Koin for dependency injection (Hilt is JVM-only)",
  "Use JetBrains navigation-compose-multiplatform for navigation",
  "Prefer immutable data models and UI state to ensure predictability",
  "Minimize coupling between UI and platform-specific code",
  
  // üì¶ Î≤ÑÏ†Ñ Í¥ÄÎ¶¨ Î∞è ÏùòÏ°¥ÏÑ±
  "Always check and use the latest stable version of libraries",
  "Use version catalog (libs.versions.toml) to manage dependency versions across modules",
  "Refer to and develop based on official documentation of libraries or frameworks",

  // üíÑ UI Íµ¨ÏÑ±
  "Avoid hardcoded strings or magic numbers ‚Äì use constants or string resources",
  "Enforce consistent UI specs via shared design tokens (spacing, typography, radius, etc.)",
  "Use previews and snapshot tests to validate UI across platforms",
  "Follow naming conventions: Composables end with 'Screen' or 'Component'",
  "Use clear and descriptive state variable names (e.g., isLoading, userName, selectedItemId)",

  // üîí Î≥¥Ïïà Î∞è ÏïàÏ†ïÏÑ±
  "Do not store secrets or keys in shared code ‚Äì use platform-specific secure storage",
  "Avoid using JVM-only APIs in commonMain",
  "Test expect/actual compatibility regularly on all platforms",
  "Apply multiplatform logging (e.g., Napier) for consistent debugging across platforms",

  // üìö ÌòëÏóÖ Î∞è Î¨∏ÏÑúÌôî
  "Document shared components with KDoc to aid collaboration and understanding",
  "Use platform-agnostic APIs first; fallback to expect/actual only when necessary",
  "Maintain platform-specific theming tokens in shared `theme/` with alias overrides"
];

const kmpProjectStructure = `
shared/
  src/
    commonMain/
      kotlin/
        model/               // Shared data models
        ui/                  // Shared UI with Compose
          screens/           // Screen-level composables
          components/        // Reusable UI components
          theme/             // Shared theme definitions
        domain/              // Use cases and interfaces
        data/                // Repository, remote, local
        util/                // Extensions, constants, helpers
    androidMain/
      kotlin/
        platform/            // Android-specific implementations
    iosMain/
      kotlin/
        platform/            // iOS-specific implementations
    webMain/
      kotlin/
        platform/            // Web-specific implementations
  build.gradle.kts
androidApp/
iosApp/
webApp/
`;

const composeMultiplatformGuidelines = `
1. Design composable functions for high reusability and separation of concerns
2. Apply state hoisting to manage UI state externally
3. Share ViewModels using KMM ViewModel pattern
4. Optimize recomposition with remember and derivedStateOf
5. Maintain consistent Modifier order (e.g., padding ‚Üí background ‚Üí clickable)
6. Use MaterialTheme with dark/light mode support
7. Provide @Preview annotations with platform-specific contexts
8. Use navigation-compose-multiplatform for navigation stack
9. Apply animations via animate*AsState, AnimatedVisibility, Crossfade, etc.
10. Ensure accessibility with contentDescription, semantics, and proper roles
`;

const kmpTestingGuidelines = `
1. Write common tests for ViewModels and UseCases in commonTest
2. Use Compose UI tests on Android; use manual verification or adapt tests for iOS
3. Use fake repositories or fake use cases to isolate dependencies
4. Handle expect/actual separation in test code as well
5. Use Coroutine Test Dispatcher for test stability and isolation
`;

const kmpPerformanceGuidelines = `
1. Reduce recomposition by assigning stable keys and using derivedStateOf
2. Use LazyColumn, LazyRow, LazyVerticalGrid for optimized list rendering
3. Use image libraries like Kamel with caching for performance
4. Combine ViewModel state with rememberSaveable for state persistence
5. Manage lifecycle with platform APIs (e.g., LifecycleOwner, iOS equivalents)
6. Use expect/actual for platform-optimized implementations where needed
`;
